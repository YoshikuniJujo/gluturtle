2011.12.30 Fri.

次にすることは、cabal file の作成。
module は Graphics.X11.Turtle で良いかと思う。
src/Graphics/X11/Turtle.hs に source code を置こう。

この段階で一度 hackage に登録してしまおう。

その次に、turtle instance を複数作れるようにしよう。
これによって readIORef に依存する変数を減らすことができるだろう。
作りとしては、newTurtle :: IO Turtle とでもして、
もしも IORef によって作成した window が undefined だったら window を open する
ことにしよう。

それと、undo 機能を、たとえば 100 くらいまでにすることによって、
speed up を図ろう。
また、python において、関数にまとめられた動作の undo がどういうふうになっているか
調べよう。

2012.01.04 Wed.

thread を利用して、ghci からでも expose event に反応するようにしたい。

2012.01.13 Fri.

infinite list を使って、状態変化を [Turtle] で表現してみたい。
これはもしかすると、GC の問題により、効率が低下する可能性がある。
そのため、test branch において作業することにする。

状態は Turtle で表現すれば良いが状態変化に伴って生じる IO をどう扱えば良いか。
Turtle 中に、draw と redraw を用意しておけば良いのかもしれない。
event は eventPoint を increment するようにする。
そして、同時に draw を実行する。

それとも Turtle の状態から、IO をその都度生成するほうが良いのかもしれない。
Event は Turtle の状態を変化させる。
その Turtle の状態の遷移から、draw や redraw 等の IO を生成するようにする、か。
Turtle の状態遷移を扱う module を TurtleState として、
基本的には Turtle -> Command -> Turtle という関数があれば良いはずだ。
Turtle の描画を扱う module を TurtleDraw として別々に作ったらどうだろうか。
こちらは Turtle -> Turtle -> IO () という関数が基本的な関数となるだろう。
Pixmap による buffer をどこで扱うかという問題もある。
undo を考えなければ Turtle -> Turtle -> IO () 関数は buffer の存在を前提として、
そこのうえに追加していく形をとれば良いだろう。
undo は原始的には直前までの Turtle による描画を buffer に書き込んで、
そのうえで undo のアニメーションを実行すれば良いだろう。

2012.01.17 Tue.

openWorld >>= initTurtle のようにすれば複数の Window のそれぞれに 複数の turtle を
置くことが可能になるだろう。

layer を重ねていく方法を考えなければならない。
これはけっこう難しい。
X Window System の機能として、透明色があれば良いのだが。

となると考え方を変えて、
それぞれの layer への描画を IO () として保存しておき、
それらの IO () を Pixmap 上に順々に描いていくってとこか。
そうすれば layer の重ね合わせが実装できる。
ただし、speed はどうかわからないが。
